[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 rsgeo authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/Getting-Started.html","id":"understanding-sf","dir":"Articles","previous_headings":"","what":"Understanding sf","title":"Getting Started","text":"R users geospatial analysis familiar sf understand spatial workflows context . Many users sf view magical data frame lets spatial analysis—exactly feels! means sf done great job making spatial analysis feel lot easier vast majority R users. sf needs understood fundamental way. sf named Simple Feature Access Standard. Simple features agreed upon way represent “geometric primitives”—things like points, linestrings, polygons, multi- types. sf package builds hierarchy . sfg, sfc, sf objects.","code":""},{"path":"/articles/Getting-Started.html","id":"sfg-objects","dir":"Articles","previous_headings":"Understanding sf","what":"sfg objects","title":"Getting Started","text":"core sfg class representations simple feature geometries. sfg class objects representations simple feature. single geometry time. can think scalar value (even though R concept scalar). scalar value can used independently useful . sfg objects simple objects constructed numeric vectors, matrices, lists matrices. also sense coordinate reference system (CRS). often want vector geometries. vector geometries stored sfc object.","code":"library(sf) #> Linking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE  # create a point pnt <- st_point(c(0, 10))  # create a line ln <- st_linestring(matrix(c(0, 1, 0, 0), ncol = 2))  class(pnt) #> [1] \"XY\"    \"POINT\" \"sfg\" class(ln) #> [1] \"XY\"         \"LINESTRING\" \"sfg\" st_length(ln) #> [1] 1"},{"path":"/articles/Getting-Started.html","id":"sfc-objects","dir":"Articles","previous_headings":"Understanding sf","what":"sfc objects","title":"Getting Started","text":"sfc short simple feature column. hood, just list sfg objects. might think create vector geometries combining using c() wrong. sfg objects behave like scalars combining creates either multi- type sfg geometry collection (another type simple feature). create vector geometries must use st_sfc(). st_sfc() construct creating “simple feature geometry list column.” lets also set number attributes associated vector. sfc objects attributes CRS, bounding box, precision. sfc objects behave like vectors familiar . Since sfc objects vectors, can included column data frame. geometry included data frame huge win R community means can included attributes along geometries. example can create vector points x y columns diamonds dataset ggplot2. can included data frame Now tibble price, clarity, geometry! Huge win! wanted calculate average price clarity keep geometries? Well, lose geometry just like column wasn’t included summarise() call. keep , need perform operation geometry . Well, wouldn’t nice geometry knew ? Well, exactly sf objects .","code":"c(pnt, pnt) #> MULTIPOINT ((0 10), (0 10)) c(pnt, ln) #> GEOMETRYCOLLECTION (POINT (0 10), LINESTRING (0 0, 1 0)) st_sfc(pnt, pnt) #> Geometry set for 2 features  #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 10 xmax: 0 ymax: 10 #> CRS:           NA #> POINT (0 10) #> POINT (0 10) c(   st_sfc(pnt, pnt),    st_sfc(pnt),   st_sfc(ln) ) #> Geometry set for 4 features  #> Geometry type: GEOMETRY #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 10 #> CRS:           NA #> POINT (0 10) #> POINT (0 10) #> POINT (0 10) #> LINESTRING (0 0, 1 0) df <- data.frame(   geo = st_sfc(pnt, pnt) )  df #>       geometry #> 1 POINT (0 10) #> 2 POINT (0 10)  class(df) #> [1] \"data.frame\" data(diamonds, package = \"ggplot2\")  pnts <- purrr::map2(   diamonds$x,    diamonds$y,    function(.x, .y) st_point(c(.x, .y)) ) |>    st_sfc() library(dplyr, warn.conflicts = FALSE)  dmnd <- diamonds |>    select(price, clarity) |>    bind_cols(geometry = pnts)  head(dmnd) #> # A tibble: 6 × 3 #>   price clarity    geometry #>   <int> <ord>       <POINT> #> 1   326 SI2     (3.95 3.98) #> 2   326 SI1     (3.89 3.84) #> 3   327 VS1     (4.05 4.07) #> 4   334 VS2      (4.2 4.23) #> 5   335 SI2     (4.34 4.35) #> 6   336 VVS2    (3.94 3.96) dmnd |>    group_by(clarity) |>    summarise(avg_price = mean(price)) #> # A tibble: 8 × 2 #>   clarity avg_price #>   <ord>       <dbl> #> 1 I1          3924. #> 2 SI2         5063. #> 3 SI1         3996. #> 4 VS2         3925. #> 5 VS1         3839. #> 6 VVS2        3284. #> 7 VVS1        2523. #> 8 IF          2865. dmnd |>    group_by(clarity) |>    summarise(     avg_price = mean(price),     geometry = st_union(geometry)   ) #> # A tibble: 8 × 3 #>   clarity avg_price                                                     geometry #>   <ord>       <dbl>                                                 <MULTIPOINT> #> 1 I1          3924. ((4.33 4.29), (4.33 4.36), (4.36 4.33), (4.38 4.42), (4.39 … #> 2 SI2         5063. ((0 0), (0 6.62), (3.79 3.75), (3.84 3.82), (3.87 3.85), (3… #> 3 SI1         3996. ((3.88 3.84), (3.89 3.84), (3.9 3.85), (3.93 3.96), (3.95 3… #> 4 VS2         3925. ((0 0), (3.73 3.68), (3.73 3.71), (3.74 3.71), (3.76 3.73),… #> 5 VS1         3839. ((0 0), (3.83 3.85), (3.84 3.87), (3.86 3.89), (3.88 3.9), … #> 6 VVS2        3284. ((3.83 3.86), (3.85 3.89), (3.85 3.9), (3.85 3.91), (3.86 3… #> 7 VVS1        2523. ((0 0), (3.83 3.85), (3.87 3.9), (3.88 3.95), (3.88 3.99), … #> 8 IF          2865. ((3.86 3.88), (3.89 3.9), (3.91 3.95), (3.92 3.94), (3.93 3…"},{"path":"/articles/Getting-Started.html","id":"sf-objects","dir":"Articles","previous_headings":"","what":"sf objects","title":"Getting Started","text":"sf objects simply just data frames geometry column sticky smart. can create sf object sfc column present data frame using st_as_sf(). creates object class sf. two things make sf object special class sf attribute sf_column. attribute tells us column geometry. sf can implement methods common functions like select(), mutate(), aggregate(), group_by(), etc always keep attr(x, \"sf_column\") attached data frame. class attribute allow methods like summarise() written class handle things like unioning geometry us. Note just like wrote earlier except didn’t handle geometry column manually. compare two approaches ignore attribute difference like sf_column class can see identical.","code":"dmnd_sf <- st_as_sf(dmnd) attr(dmnd_sf, \"sf_column\") #> [1] \"geometry\" dmnd_sf |>    group_by(clarity) |>    summarise(avg_price = mean(price)) #> Simple feature collection with 8 features and 2 fields #> Geometry type: MULTIPOINT #> Dimension:     XY #> Bounding box:  xmin: 0 ymin: 0 xmax: 10.74 ymax: 58.9 #> CRS:           NA #> # A tibble: 8 × 3 #>   clarity avg_price                                                     geometry #>   <ord>       <dbl>                                                 <MULTIPOINT> #> 1 I1          3924. ((4.33 4.29), (4.33 4.36), (4.36 4.33), (4.38 4.42), (4.39 … #> 2 SI2         5063. ((0 0), (0 6.62), (3.79 3.75), (3.84 3.82), (3.87 3.85), (3… #> 3 SI1         3996. ((3.88 3.84), (3.89 3.84), (3.9 3.85), (3.93 3.96), (3.95 3… #> 4 VS2         3925. ((0 0), (3.73 3.68), (3.73 3.71), (3.74 3.71), (3.76 3.73),… #> 5 VS1         3839. ((0 0), (3.83 3.85), (3.84 3.87), (3.86 3.89), (3.88 3.9), … #> 6 VVS2        3284. ((3.83 3.86), (3.85 3.89), (3.85 3.9), (3.85 3.91), (3.86 3… #> 7 VVS1        2523. ((0 0), (3.83 3.85), (3.87 3.9), (3.88 3.95), (3.88 3.99), … #> 8 IF          2865. ((3.86 3.88), (3.89 3.9), (3.91 3.95), (3.92 3.94), (3.93 3… x <- dmnd |>    group_by(clarity) |>    summarise(     avg_price = mean(price),     geometry = st_union(geometry)   )  y <- dmnd_sf |>    group_by(clarity) |>    summarise(avg_price = mean(price))  all.equal(x, y, check.attributes = FALSE) #> [1] TRUE"},{"path":"/articles/Getting-Started.html","id":"freeing-yourself","dir":"Articles","previous_headings":"","what":"Freeing yourself","title":"Getting Started","text":"Knowing sf works can helpful understanding can ease reliance geospatial operations. Instead thinking entire sf data frame thing handles geometry operations now know sfc geometry column. R different ways representing geometry besides sfc vectors. packages s2, geos, wk, rsgeo provide different vectors geometries can used. libraries handy geometric operations. packages tend better one thing another place. often find big speed improvements use libraries instead sf certain things. Take example calculating length linestrings geodesic. can use roxel dataset sfnetworks. illustrate can extract geometry column cast rsgeo class object. can use functions st_length() length_haversine() respectively compute length linestrings. markedly faster using rsgeo. also extract vector work object. vector can included data frame, remember?","code":"data(roxel, package = \"sfnetworks\") library(rsgeo) geo <- roxel$geometry rs <- as_rsgeo(geo) bench::mark(   st_length(geo),   length_haversine(rs),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression                min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>           <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 st_length(geo)         2.28ms   2.41ms      393.    2.89MB     17.0 #> 2 length_haversine(rs) 272.65µs 758.05µs     1161.     8.8KB      0 roxel |>    as_tibble() |>    mutate(length = length_haversine(as_rsgeo(geometry))) #> # A tibble: 851 × 4 #>    name                  type                                    geometry length #>    <chr>                 <fct>                           <LINESTRING [°]>  <dbl> #>  1 Havixbecker Strasse   residential (7.533722 51.95556, 7.533461 51.955…   28.8 #>  2 Pienersallee          secondary   (7.532442 51.95422, 7.53236 51.9537…  108.  #>  3 Schulte-Bernd-Strasse residential (7.532709 51.95209, 7.532823 51.952…   54.3 #>  4 NA                    path        (7.540063 51.94468, 7.539696 51.944…  155.  #>  5 Welsingheide          residential (7.537673 51.9475, 7.537614 51.9456…  209.  #>  6 NA                    footway     (7.543791 51.94733, 7.54369 51.9468…   63.0 #>  7 NA                    footway     (7.54012 51.94478, 7.539931 51.9451…   42.2 #>  8 NA                    path        (7.53822 51.94546, 7.538131 51.9454…   45.3 #>  9 NA                    track       (7.540063 51.94468, 7.540338 51.944…  348.  #> 10 NA                    track       (7.5424 51.94599, 7.54205 51.94629,…  145.  #> # ℹ 841 more rows"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Josiah Parry. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Parry J (2023). rsgeo: Interface Rust's 'geo' Library. https://github.com/JosiahParry/rsgeo, https://josiahparry.r-universe.dev/rsgeo, https://rsgeo.josiahparry.com/.","code":"@Manual{,   title = {rsgeo: An Interface to Rust's 'geo' Library},   author = {Josiah Parry},   year = {2023},   note = {https://github.com/JosiahParry/rsgeo, https://josiahparry.r-universe.dev/rsgeo, https://rsgeo.josiahparry.com/}, }"},{"path":"/index.html","id":"rsgeo","dir":"","previous_headings":"","what":"An Interface to Rusts geo' Library","title":"An Interface to Rusts geo' Library","text":"rsgeo interface Rust libraries geo-types geo. geo-types implements pure rust geometry primitives. geo library adds additional algorithm functionalities top geo-types. package lets harness speed, safety, memory efficiency libraries. geo-types support Z M dimensions. support CRS moment. rsgeo works vectors geometries. compare sf always geometry column class sfc object (simple feature column). Cast geometries sf Calculate unsigned area polygons. Find centroids Extract points coordinates Plot polygons centroids  Calculate distance matrix. Note often floating point error differences check = FALSE case. Simplify geometries.  Union geometries union_geoms(). things sf better ! One performing unary unions complex geometries.  can cast geometries well. unions faster using rsgeo vectors like linestrings. Find closest point geometry  Find haversine destination point, bearing, distance. Compare fast geosphere destination point function.  Find intermediate point great circle.  Find extreme coordinates extreme_coords()  Get bounding rectangles  Convex hulls  Expand constituent geometries list geometry vectors can flatten resultant geometries single vector using flatten_geoms() Combine geometries single multi- geometry Spatial predicates","code":"# install.packages( #   'rsgeo',  #   repos = c('https://josiahparry.r-universe.dev', 'https://cloud.r-project.org') # ) library(rsgeo) # get geometry from sf data(guerry, package = \"sfdep\")  polys <- guerry[[\"geometry\"]] |>   sf::st_cast(\"POLYGON\")  # cast to rust geo-types rs_polys <- as_rsgeo(polys)  head(rs_polys) #> <rs_POLYGON[6]> #> [1] Polygon { exterior: LineString([Coord { x: 801150.0, y: 2092615.0 }, Coord... #> [2] Polygon { exterior: LineString([Coord { x: 729326.0, y: 2521619.0 }, Coord... #> [3] Polygon { exterior: LineString([Coord { x: 710830.0, y: 2137350.0 }, Coord... #> [4] Polygon { exterior: LineString([Coord { x: 882701.0, y: 1920024.0 }, Coord... #> [5] Polygon { exterior: LineString([Coord { x: 886504.0, y: 1922890.0 }, Coord... #> [6] Polygon { exterior: LineString([Coord { x: 747008.0, y: 1925789.0 }, Coord... sf::st_as_sfc(rs_polys) #> Geometry set for 116 features  #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 47680 ymin: 1703258 xmax: 1031401 ymax: 2677441 #> CRS:           NA #> First 5 geometries: #> POLYGON ((801150 2092615, 800669 2093190, 80068... #> POLYGON ((729326 2521619, 729320 2521230, 72928... #> POLYGON ((710830 2137350, 711746 2136617, 71243... #> POLYGON ((882701 1920024, 882408 1920733, 88177... #> POLYGON ((886504 1922890, 885733 1922978, 88547... bench::mark(   rust = unsigned_area(rs_polys),   sf = sf::st_area(polys),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 rust         55.6µs  57.65µs    16411.     3.8KB     0    #> 2 sf           1.36ms   1.44ms      649.   786.9KB     8.42 bench::mark(   centroids(rs_polys),   sf::st_centroid(polys),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression                  min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>             <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 centroids(rs_polys)    174.95µs    213µs     3720.     3.8KB     9.53 #> 2 sf::st_centroid(polys)   2.43ms    2.6ms      359.   892.9KB     4.70 coords(rs_polys) |>    head() #>        x       y line_id polygon_id #> 1 801150 2092615       1          1 #> 2 800669 2093190       1          1 #> 3 800688 2095430       1          1 #> 4 800780 2095795       1          1 #> 5 800589 2096112       1          1 #> 6 800333 2097190       1          1 plot(rs_polys) plot(centroids(rs_polys), add = TRUE) pnts <- centroids(rs_polys) pnts_sf <- sf::st_as_sfc(pnts)  bench::mark(   rust = distance_euclidean_matrix(pnts, pnts),   sf = sf::st_distance(pnts_sf, pnts_sf),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 rust       323.53µs 573.06µs     1540.     108KB     4.08 #> 2 sf           3.48ms   3.69ms      256.     351KB     0 x <- rs_polys x_simple <- simplify_geoms(x, 5000)  plot(x_simple) bench::mark(   rust = simplify_geoms(rs_polys, 500),   sf = sf::st_simplify(polys, FALSE, 500),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 rust         6.29ms   6.76ms      141.    1.91KB     0    #> 2 sf           8.52ms   9.02ms      108.    1.24MB     2.08 plot(union_geoms(rs_polys)) bench::mark(   union_geoms(rs_polys),   sf::st_union(polys),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression                 min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>            <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 union_geoms(rs_polys)    205ms    209ms      4.78        0B        0 #> 2 sf::st_union(polys)      120ms    134ms      7.49     921KB        0 lns <- cast_geoms(rs_polys, \"linestring\") lns_sf <- sf::st_cast(polys, \"LINESTRING\")  bench::mark(   union_geoms(lns),   sf::st_union(lns_sf),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression                min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>           <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 union_geoms(lns)      117.5µs    174µs    4275.         0B     0    #> 2 sf::st_union(lns_sf)   87.8ms     94ms      10.7    2.46MB     2.68 close_pnt <- closest_point(   rs_polys,    geom_point(800000, 2090000) )  plot(rs_polys[1]) plot(close_pnt, pch = 15, add = TRUE) bench::mark(   rust = haversine_destination(geom_point(10, 10), 45, 10000),   Cpp = geosphere::destPoint(c(10, 10), 45, 10000),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 rust         5.86µs   7.34µs   120442.     3.2KB     12.0 #> 2 Cpp         17.06µs  19.11µs    34150.    11.8MB     34.2 origin <- geom_point(10, 10)  destination <- haversine_destination(origin, 45, 10000)  plot(c(origin, destination), col = c(\"red\", \"blue\")) middle <- haversine_intermediate(origin, destination, 1/2)  plot(origin) plot(destination, add = TRUE, col = \"red\") plot(middle, add = TRUE, col = \"blue\") france <- union_geoms(rs_polys)  plot(france) plot(extreme_coords(france)[[1]], add = TRUE, pch = 15) rects <- bounding_rect(rs_polys) plot(rects) convex_hull(rs_polys) |>    plot() expand_geoms(rs_polys) |>    head() #> [[1]] #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 801150.0, y: 2092615.0 }, Coord { x: 800669.0, y: 2... #>  #> [[2]] #> <rs_LINESTRING[2]> #> [1] LineString([Coord { x: 729326.0, y: 2521619.0 }, Coord { x: 729320.0, y: 2... #> [2] LineString([Coord { x: 647667.0, y: 2468296.0 }, Coord { x: 647777.0, y: 2... #>  #> [[3]] #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 710830.0, y: 2137350.0 }, Coord { x: 711746.0, y: 2... #>  #> [[4]] #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 882701.0, y: 1920024.0 }, Coord { x: 882408.0, y: 1... #>  #> [[5]] #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 886504.0, y: 1922890.0 }, Coord { x: 885733.0, y: 1... #>  #> [[6]] #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 747008.0, y: 1925789.0 }, Coord { x: 746630.0, y: 1... expand_geoms(rs_polys) |>    flatten_geoms() |>    head() #> <rs_LINESTRING[6]> #> [1] LineString([Coord { x: 801150.0, y: 2092615.0 }, Coord { x: 800669.0, y: 2... #> [2] LineString([Coord { x: 729326.0, y: 2521619.0 }, Coord { x: 729320.0, y: 2... #> [3] LineString([Coord { x: 647667.0, y: 2468296.0 }, Coord { x: 647777.0, y: 2... #> [4] LineString([Coord { x: 710830.0, y: 2137350.0 }, Coord { x: 711746.0, y: 2... #> [5] LineString([Coord { x: 882701.0, y: 1920024.0 }, Coord { x: 882408.0, y: 1... #> [6] LineString([Coord { x: 886504.0, y: 1922890.0 }, Coord { x: 885733.0, y: 1... combine_geoms(lns) #> <rs_LINESTRING[1]> #> [1] MultiLineString([LineString([Coord { x: 801150.0, y: 2092615.0 }, Coord { ... x <- rs_polys[1:5] intersects_sparse(x, rs_polys) #> [[1]] #> [1]  1 48 50 92 94 #>  #> [[2]] #> [1]   2   7  63  78  80  81  98 101 #>  #> [[3]] #> [1]  3 20 27 53 77 84 94 #>  #> [[4]] #> [1]   4   5  30 107 109 #>  #> [[5]] #> [1]  4  5 30 48"},{"path":"/index.html","id":"notes","dir":"","previous_headings":"","what":"Notes","title":"An Interface to Rusts geo' Library","text":"Right now plotting done using wk first casting rsgeo sfc object.","code":""},{"path":"/reference/area.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the area of a polygon — signed_area","title":"Calculate the area of a polygon — signed_area","text":"Functions calculate different types area polygons.","code":""},{"path":"/reference/area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the area of a polygon — signed_area","text":"","code":"signed_area(x)  unsigned_area(x)  signed_area_cd(x)  unsigned_area_cd(x)  signed_area_geodesic(x)  unsigned_area_geodesic(x)"},{"path":"/reference/area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the area of a polygon — signed_area","text":"x object class rsgeo","code":""},{"path":"/reference/area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the area of a polygon — signed_area","text":"numeric vector area contained geometry","code":""},{"path":"/reference/area.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the area of a polygon — signed_area","text":"functions assume counter clock-wise winding accordance simple feature access standard functions ending _cd use Chamberlain-Duquette algorithm spherical area Chamberlain-Duquette Geodesic areas returned meters squared assume non-planar geometries See geo docs : GeodesicArea Area ChamberlainDuquetteArea","code":""},{"path":"/reference/area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the area of a polygon — signed_area","text":"","code":"x <- c(0, 1, 1, 0, 0) y <- c(0, 0, 1, 1, 0) p <- geom_polygon(x, y)  signed_area(p) #> [1] 1 unsigned_area(p) #> [1] 1 signed_area_cd(p) #> [1] 12391399902 unsigned_area_cd(p) #> [1] 12391399902 signed_area_geodesic(p) #> [1] 12308778361 unsigned_area_geodesic(p) #> [1] 12308778361"},{"path":"/reference/as_rsgeo.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to an rsgeo vector — as_rsgeo","title":"Convert to an rsgeo vector — as_rsgeo","text":"Given vector geometries, cast rsgeo class object.","code":""},{"path":"/reference/as_rsgeo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to an rsgeo vector — as_rsgeo","text":"","code":"as_rsgeo(x)"},{"path":"/reference/as_rsgeo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to an rsgeo vector — as_rsgeo","text":"x geometry vector","code":""},{"path":"/reference/as_rsgeo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to an rsgeo vector — as_rsgeo","text":"object class rsgeo","code":""},{"path":"/reference/as_rsgeo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to an rsgeo vector — as_rsgeo","text":"","code":"x <- sf::st_sfc(sf::st_point(c(0,0))) as_rsgeo(x) #> <rs_POINT[1]> #> [1] Point(Coord { x: 0.0, y: 0.0 }))"},{"path":"/reference/as_rsgeom.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert sf object to a Rust geo_type — as_rsgeom","title":"Convert sf object to a Rust geo_type — as_rsgeom","text":"Convert sf object Rust geo_type","code":""},{"path":"/reference/as_rsgeom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert sf object to a Rust geo_type — as_rsgeom","text":"","code":"as_rsgeom(x)"},{"path":"/reference/as_rsgeom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert sf object to a Rust geo_type — as_rsgeom","text":"x sfc sfg object","code":""},{"path":"/reference/as_sfg.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert geo-type to sfg or sfc object — as_sfg","title":"Convert geo-type to sfg or sfc object — as_sfg","text":"Convert geo-type sfg sfc object","code":""},{"path":"/reference/as_sfg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert geo-type to sfg or sfc object — as_sfg","text":"","code":"as_sfg(x)"},{"path":"/reference/as_sfg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert geo-type to sfg or sfc object — as_sfg","text":"x rust geo-type","code":""},{"path":"/reference/bearing.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Bearing — bearing_geodesic","title":"Calculate Bearing — bearing_geodesic","text":"Calculates bearing two point geometries.","code":""},{"path":"/reference/bearing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Bearing — bearing_geodesic","text":"","code":"bearing_geodesic(x, y)  bearing_haversine(x, y)"},{"path":"/reference/bearing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Bearing — bearing_geodesic","text":"x object class rs_POINT y object class rs_POINT","code":""},{"path":"/reference/bearing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Bearing — bearing_geodesic","text":"vector doubles calculated bearing x y","code":""},{"path":"/reference/bearing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Bearing — bearing_geodesic","text":"","code":"x <- geom_point(runif(10, 0, 90), rnorm(10, 1, 90)) y <- geom_point(runif(10, 0, 90), rnorm(10, 1, 90)) bearing_geodesic(x, y) #>  [1]       NaN 135.80725       NaN       NaN       NaN       NaN       NaN #>  [8] -21.55129 169.04503       NaN bearing_haversine(x, y) #>  [1]    7.392928  135.989047 -166.914024  163.038482  -23.118246 -164.293259 #>  [7]   18.541634  -21.453923  169.091074 -166.403590"},{"path":"/reference/boundaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Geometric Boundaries — bounding_boxes","title":"Compute Geometric Boundaries — bounding_boxes","text":"vector geometries identify different types boundaries.","code":""},{"path":"/reference/boundaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Geometric Boundaries — bounding_boxes","text":"","code":"bounding_boxes(x)  bounding_rect(x)  minimum_rotated_rect(x)  convex_hull(x)  concave_hull(x, concavity)  extreme_coords(x)  bounding_box(x)"},{"path":"/reference/boundaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Geometric Boundaries — bounding_boxes","text":"x object class rsgeo concavity value 0 1 specifying concavity convex hull","code":""},{"path":"/reference/boundaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Geometric Boundaries — bounding_boxes","text":"bounding_box() returns named vector xmin, ymin, xmax, ymax bounding_boxes() returns list bounding box numeric vectors geometry bounding_rect() returns rs_POLYGON bounding rectangle geometry convex_hull() returns rs_POLYGON convex hull geometry concave_hull() returns rs_POLYGON specified concavity geometry extreme_coords() returns extreme coordinates geometry list element named vector xmin, ymin, xmax, ymax element Point geometry extreme value minimum_rotated_rect() returns minimum rotated rectangle covering geometry rs_POLYGON","code":""},{"path":"/reference/boundaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Geometric Boundaries — bounding_boxes","text":"Note want convex concave hull entire vector geometries must first union combine using either combine_geoms() union_geoms()","code":""},{"path":"/reference/boundaries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Geometric Boundaries — bounding_boxes","text":"","code":"lns <- geom_linestring(   1:20,   runif(20, -5, 5),   rep.int(1:5, 4) ) bounding_box(lns) #>      xmin      ymin      xmax      ymax  #>  1.000000 -4.144445 20.000000  4.747889  bounding_boxes(lns) #> [[1]] #>      xmin      ymin      xmax      ymax  #>  5.000000 -3.419542 20.000000  4.747889  #>  #> [[2]] #>      xmin      ymin      xmax      ymax  #>  3.000000 -4.144445 18.000000  4.180226  #>  #> [[3]] #>       xmin       ymin       xmax       ymax  #>  2.0000000 -0.8920076 17.0000000  4.1903656  #>  #> [[4]] #>       xmin       ymin       xmax       ymax  #>  1.0000000 -0.9795162 16.0000000  4.4174207  #>  #> [[5]] #>      xmin      ymin      xmax      ymax  #>  4.000000 -2.921366 19.000000  1.610642  #>  minimum_rotated_rect(lns) #> <rs_POLYGON[5]> #> [1] Polygon { exterior: LineString([Coord { x: 4.427032599912608, y: -2.026464... #> [2] Polygon { exterior: LineString([Coord { x: 8.000000000000002, y: 4.1802260... #> [3] Polygon { exterior: LineString([Coord { x: 1.9999999999999993, y: 1.792893... #> [4] Polygon { exterior: LineString([Coord { x: 16.000000000000004, y: 4.417420... #> [5] Polygon { exterior: LineString([Coord { x: 4.0, y: -2.921365625225008 }, C... convex_hull(lns) #> <rs_POLYGON[5]> #> [1] Polygon { exterior: LineString([Coord { x: 10.0, y: -2.524993175175041 }, ... #> [2] Polygon { exterior: LineString([Coord { x: 18.0, y: -2.939579407684505 }, ... #> [3] Polygon { exterior: LineString([Coord { x: 17.0, y: -0.8920075697824359 },... #> [4] Polygon { exterior: LineString([Coord { x: 6.0, y: -0.97951615229249 }, Co... #> [5] Polygon { exterior: LineString([Coord { x: 14.0, y: -1.5909375040791929 },... concave_hull(lns, 0.5) #> <rs_POLYGON[5]> #> [1] Polygon { exterior: LineString([Coord { x: 10.0, y: -2.524993175175041 }, ... #> [2] Polygon { exterior: LineString([Coord { x: 18.0, y: -2.939579407684505 }, ... #> [3] Polygon { exterior: LineString([Coord { x: 17.0, y: -0.8920075697824359 },... #> [4] Polygon { exterior: LineString([Coord { x: 6.0, y: -0.97951615229249 }, Co... #> [5] Polygon { exterior: LineString([Coord { x: 14.0, y: -1.5909375040791929 },... extreme_coords(lns) #> [[1]] #> <rs_POINT[4]> #>                                              xmin  #>   Point(Coord { x: 5.0, y: 4.3786372523754835 }))  #>                                              ymin  #> Point(Coord { x: 20.0, y: -3.4195416909642518 }))  #>                                              xmax  #> Point(Coord { x: 20.0, y: -3.4195416909642518 }))  #>                                              ymax  #>   Point(Coord { x: 15.0, y: 4.747889121063054 }))  #>  #> [[2]] #> <rs_POINT[4]> #>                                             xmin  #>  Point(Coord { x: 3.0, y: -4.144444735720754 }))  #>                                             ymin  #>  Point(Coord { x: 3.0, y: -4.144444735720754 }))  #>                                             xmax  #> Point(Coord { x: 18.0, y: -2.939579407684505 }))  #>                                             ymax  #>   Point(Coord { x: 8.0, y: 4.180226030293852 }))  #>  #> [[3]] #> <rs_POINT[4]> #>                                              xmin  #>   Point(Coord { x: 2.0, y: 1.7928934353403747 }))  #>                                              ymin  #> Point(Coord { x: 17.0, y: -0.8920075697824359 }))  #>                                              xmax  #> Point(Coord { x: 17.0, y: -0.8920075697824359 }))  #>                                              ymax  #>   Point(Coord { x: 12.0, y: 4.190365644171834 }))  #>  #> [[4]] #> <rs_POINT[4]> #>                                            xmin  #> Point(Coord { x: 1.0, y: 2.9216841561719775 }))  #>                                            ymin  #>  Point(Coord { x: 6.0, y: -0.97951615229249 }))  #>                                            xmax  #> Point(Coord { x: 16.0, y: 4.417420718818903 }))  #>                                            ymax  #> Point(Coord { x: 16.0, y: 4.417420718818903 }))  #>  #> [[5]] #> <rs_POINT[4]> #>                                             xmin  #> Point(Coord { x: 4.0, y: -2.9213656252250075 }))  #>                                             ymin  #> Point(Coord { x: 4.0, y: -2.9213656252250075 }))  #>                                             xmax  #>  Point(Coord { x: 19.0, y: 1.314457633998245 }))  #>                                             ymax  #>  Point(Coord { x: 9.0, y: 1.6106420522555709 }))  #>"},{"path":"/reference/cast_geoms.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast geometries to another type — cast_geoms","title":"Cast geometries to another type — cast_geoms","text":"Cast geometries another type","code":""},{"path":"/reference/cast_geoms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast geometries to another type — cast_geoms","text":"","code":"cast_geoms(x, to)"},{"path":"/reference/cast_geoms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast geometries to another type — cast_geoms","text":"x object class rsgeo character scalar target geometry type. Must one \"point\", \"multipoint\", \"polygon\", \"multipolygon\", \"linestring\", \"multilinestring\".","code":""},{"path":"/reference/cast_geoms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast geometries to another type — cast_geoms","text":"object class rsgeo","code":""},{"path":"/reference/cast_geoms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cast geometries to another type — cast_geoms","text":"conversions made available. left hand column indicates originating vector class right hand column indicates class can cast . Note correctness conversions checked verified. cast rs_MULTIPOINT rs_POLYGON, validity polygon guaranteed. Conversions rs_POLYGON rs_LINESTRING result exterior ring polygon ignoring interior rings .","code":""},{"path":"/reference/cast_geoms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast geometries to another type — cast_geoms","text":"","code":"ply <- geom_polygon(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0)) cast_geoms(ply, \"linestring\") #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 0.0, y: 0.0 }, Coord { x: 1.0, y: 0.0 }, Coord { x:... cast_geoms(ply, \"multipoint\") #> <rs_MULTIPOINT[1]> #> [1] MultiPoint([Point(Coord { x: 0.0, y: 0.0 }), Point(Coord { x: 1.0, y: 0.0 ..."},{"path":"/reference/centroid.html","id":null,"dir":"Reference","previous_headings":"","what":"Find centroid — centroid","title":"Find centroid — centroid","text":"Find centroid","code":""},{"path":"/reference/centroid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find centroid — centroid","text":"","code":"centroid(x)  centroids(x)"},{"path":"/reference/centroid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find centroid — centroid","text":"x object class point","code":""},{"path":"/reference/centroids.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Centroids — centroids","title":"Extract Centroids — centroids","text":"Given vector geometries, extract centroids.","code":""},{"path":"/reference/centroids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Centroids — centroids","text":"","code":"centroids(x)"},{"path":"/reference/centroids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Centroids — centroids","text":"x object class rsgeo","code":""},{"path":"/reference/centroids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Centroids — centroids","text":"object class rs_POINT","code":""},{"path":"/reference/centroids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Centroids — centroids","text":"","code":"lns <- geom_linestring(1:100, runif(100, -10, 10), rep.int(1:5, 20)) centroids(lns) #> <rs_POINT[5]> #> [1] Point(Coord { x: 50.85323516315266, y: 0.5487884624330192 }))   #> [2] Point(Coord { x: 43.28121065833406, y: -0.9099755665119409 }))  #> [3] Point(Coord { x: 50.722853340740315, y: 0.6575253615073913 }))  #> [4] Point(Coord { x: 48.81807331672222, y: -0.43884191432112574 })) #> [5] Point(Coord { x: 51.64827952415451, y: 1.15103438249401 }))"},{"path":"/reference/chaikin_smoothing.html","id":null,"dir":"Reference","previous_headings":"","what":"Chaikin Smoothing — chaikin_smoothing","title":"Chaikin Smoothing — chaikin_smoothing","text":"Chaikin Smoothing","code":""},{"path":"/reference/chaikin_smoothing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chaikin Smoothing — chaikin_smoothing","text":"","code":"chaikin_smoothing(x, niter)"},{"path":"/reference/closest_point.html","id":null,"dir":"Reference","previous_headings":"","what":"Find Closest Point — closest_point","title":"Find Closest Point — closest_point","text":"given geometry, find closest point geometry point. closest point may intersection, single point, unable determined.","code":""},{"path":"/reference/closest_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find Closest Point — closest_point","text":"","code":"closest_point(x, y)  closest_point_haversine(x, y)"},{"path":"/reference/closest_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find Closest Point — closest_point","text":"x object class rsgeo y object class rs_POINT","code":""},{"path":"/reference/closest_point.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find Closest Point — closest_point","text":"rs_POINT vector","code":""},{"path":"/reference/closest_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find Closest Point — closest_point","text":"","code":"x <- geom_linestring(1:100, runif(100, 0, 90), rep.int(1:10, 10)) y <- geom_point(runif(10, 0, 90), rnorm(10, 1, 90)) closest_point(x, y) #> <rs_POINT[10]> #>  [1] Point(Coord { x: 5.0, y: 7.449113731272519 }))   #>  [2] Point(Coord { x: 81.0, y: 29.840561191085726 })) #>  [3] Point(Coord { x: 36.0, y: 4.523327888455242 }))  #>  [4] Point(Coord { x: 67.0, y: 16.668208139017224 })) #>  [5] Point(Coord { x: 20.0, y: 11.72312163747847 }))  #>  [6] Point(Coord { x: 83.0, y: 28.56330905808136 }))  #>  [7] Point(Coord { x: 14.0, y: 4.244143373798579 }))  #>  [8] Point(Coord { x: 9.0, y: 30.438028047792614 }))  #>  [9] Point(Coord { x: 2.0, y: 16.038183497730643 }))  #> [10] Point(Coord { x: 48.0, y: 11.376974894665182 })) closest_point_haversine(x, y) #> <rs_POINT[10]> #>  [1] Point(Coord { x: 5.0, y: 7.449113731272519 }))   #>  [2] Point(Coord { x: 81.0, y: 29.840561191085726 })) #>  [3] Point(Coord { x: 36.0, y: 4.523327888455242 }))  #>  [4] Point(Coord { x: 67.0, y: 16.668208139017224 })) #>  [5] Point(Coord { x: 20.0, y: 11.72312163747847 }))  #>  [6] Point(Coord { x: 83.0, y: 28.56330905808136 }))  #>  [7] Point(Coord { x: 84.0, y: 84.27560745505616 }))  #>  [8] Point(Coord { x: 9.0, y: 30.438028047792614 }))  #>  [9] Point(Coord { x: 92.0, y: 2.127406275831163 }))  #> [10] Point(Coord { x: 48.0, y: 11.376974894665182 }))"},{"path":"/reference/combine_geoms.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine geometries — combine_geoms","title":"Combine geometries — combine_geoms","text":"Given vector geometries combine single geometry.","code":""},{"path":"/reference/combine_geoms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine geometries — combine_geoms","text":"","code":"combine_geoms(x)  union_geoms(x)"},{"path":"/reference/combine_geoms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine geometries — combine_geoms","text":"x object class rsgeo","code":""},{"path":"/reference/combine_geoms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine geometries — combine_geoms","text":"object class rsgeo length one.","code":""},{"path":[]},{"path":"/reference/combine_geoms.html","id":"combine-geoms-","dir":"Reference","previous_headings":"","what":"combine_geoms()","title":"Combine geometries — combine_geoms","text":"combine_geoms() combines vector geometries vector length one MULTI counterpart. rs_POINT rs_MULTIPOINT -> rs_MULTIPOINT rs_LINESTRING rs_MULTILINESTRING -> rs_MULTILINESTRING rs_POLYGON rs_MULTIPOLYGON -> rs_MULTIPOLYGON rs_GEOMETRYCOLLECTION supported","code":""},{"path":"/reference/combine_geoms.html","id":"union-geoms-","dir":"Reference","previous_headings":"","what":"union_geoms()","title":"Combine geometries — combine_geoms","text":"union_geoms() creates union geometries removing repeated points dissolving shared boundaries. rs_POINT - combines removes repeated points rs_MULTIPOINT - combines removes repeated points rs_LINESTRING - combines removes duplicated points rs_MULTILINESTRING - combines removes duplicated points rs_POLYGON - unions geometries single geometry rs_MULTIPOLYGON - unions geometries single geometry","code":""},{"path":"/reference/combine_geoms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine geometries — combine_geoms","text":"","code":"pnts <- geom_point(runif(10), runif(10)) combine_geoms(pnts) #> <rs_POINT[1]> #> [1] MultiPoint([Point(Coord { x: 0.4734771477524191, y: 0.9752697139047086 }),...  lns <- geom_linestring(1:100, runif(100, -10, 10), rep.int(1:5, 20)) union_geoms(lns) #> <rs_MULTILINESTRING[1]> #> [1] MultiLineString([LineString([Coord { x: 1.0, y: -3.2701129419729114 }, Coo...  x <- c(0, 1, 1, 0, 0) y <- c(0, 0, 1, 1, 0)  p1 <- geom_polygon(x, y) p2 <- geom_polygon(x - 1, y + 0.5)  z <- c(p1, p2)  res <- union_geoms(z) res #> <rs_MULTIPOLYGON[1]> #> [1] MultiPolygon([Polygon { exterior: LineString([Coord { x: 0.0, y: 0.5 }, Co...  if (rlang::is_installed(c(\"sf\", \"wk\"))) {   plot(z)   plot(res, lty = 3, border = \"blue\", add = TRUE, lwd = 4) }"},{"path":"/reference/construction.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct Geometries — geom_point","title":"Construct Geometries — geom_point","text":"Constructs geometries numeric vectors.","code":""},{"path":"/reference/construction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct Geometries — geom_point","text":"","code":"geom_point(x, y)  geom_multipoint(x, y, id = 1)  geom_linestring(x, y, id = 1)  geom_polygon(x, y, id = 1, ring = 1)"},{"path":"/reference/construction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct Geometries — geom_point","text":"x vector x coordinates y vector y coordinates id feature identifier ring id polygon ring","code":""},{"path":"/reference/construction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct Geometries — geom_point","text":"object class rsgeo","code":""},{"path":"/reference/construction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct Geometries — geom_point","text":"","code":"geom_point(3, 0.14) #> <rs_POINT[1]> #> [1] Point(Coord { x: 3.0, y: 0.14 })) geom_multipoint(1:10, 10:1) #> <rs_MULTIPOINT[1]> #> [1] MultiPoint([Point(Coord { x: 1.0, y: 10.0 }), Point(Coord { x: 2.0, y: 9.0... geom_linestring(1:10, 10:1) #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 1.0, y: 10.0 }, Coord { x: 2.0, y: 9.0 }, Coord { x... geom_polygon(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0)) #> <rs_POLYGON[1]> #> [1] Polygon { exterior: LineString([Coord { x: 0.0, y: 0.0 }, Coord { x: 1.0, ..."},{"path":"/reference/convex.html","id":null,"dir":"Reference","previous_headings":"","what":"Determine the Convexity of a LineString — is_convex","title":"Determine the Convexity of a LineString — is_convex","text":"given rs_LINESTRING vector, test convexity. Convexity can tested strictly strongly, well based winding.","code":""},{"path":"/reference/convex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Determine the Convexity of a LineString — is_convex","text":"","code":"is_convex(x)  is_ccw_convex(x)  is_cw_convex(x)  is_strictly_convex(x)  is_strictly_ccw_convex(x)  is_strictly_cw_convex(x)"},{"path":"/reference/convex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Determine the Convexity of a LineString — is_convex","text":"x object class rs_LINESTRING See geo docs details","code":""},{"path":"/reference/convex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Determine the Convexity of a LineString — is_convex","text":"logical vector","code":""},{"path":"/reference/convex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Determine the Convexity of a LineString — is_convex","text":"","code":"lns <- geom_linestring(     1:20,     runif(20, -5, 5),     rep.int(1:5, 4)   )    is_convex(lns) #> [1] FALSE FALSE FALSE FALSE FALSE is_cw_convex(lns) #> [1] FALSE FALSE FALSE FALSE FALSE is_ccw_convex(lns) #> [1] FALSE FALSE FALSE FALSE FALSE is_strictly_convex(lns) #> [1] FALSE FALSE FALSE FALSE FALSE is_strictly_cw_convex(lns) #> [1] FALSE FALSE FALSE FALSE FALSE is_strictly_ccw_convex(lns) #> [1] FALSE FALSE FALSE FALSE FALSE"},{"path":"/reference/coords.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Coordinates — coords","title":"Extract Coordinates — coords","text":"Given rsgeo class object, extract object's coordinates data frame. Empty missing geometries ignored.","code":""},{"path":"/reference/coords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Coordinates — coords","text":"","code":"coords(x)"},{"path":"/reference/coords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Coordinates — coords","text":"x object class rsgeo","code":""},{"path":"/reference/coords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Coordinates — coords","text":"data.frame columns x, y. Additional columns returned based geometry type. Additional columns : id line_id: refers LineString ID rs_LINESTRING, component LineString MultiLineString, ring ID Polygon. multilinestring_id polygon_id multipolygon_id","code":""},{"path":"/reference/coords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Coordinates — coords","text":"","code":"pnt <- geom_point(3, 0.14) mpnt <- geom_multipoint(1:10, 10:1) ln <- geom_linestring(1:10, 10:1) ply <- geom_polygon(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))  coords(pnt) #>   x    y #> 1 3 0.14 coords(mpnt) #>     x  y id #> 1   1 10  1 #> 2   2  9  1 #> 3   3  8  1 #> 4   4  7  1 #> 5   5  6  1 #> 6   6  5  1 #> 7   7  4  1 #> 8   8  3  1 #> 9   9  2  1 #> 10 10  1  1 coords(ln) #>     x  y line_id #> 1   1 10       1 #> 2   2  9       1 #> 3   3  8       1 #> 4   4  7       1 #> 5   5  6       1 #> 6   6  5       1 #> 7   7  4       1 #> 8   8  3       1 #> 9   9  2       1 #> 10 10  1       1 coords(union_geoms(rep(ln, 2))) #>     x  y line_id multilinestring_id #> 1   1 10       1                  1 #> 2   2  9       1                  1 #> 3   3  8       1                  1 #> 4   4  7       1                  1 #> 5   5  6       1                  1 #> 6   6  5       1                  1 #> 7   7  4       1                  1 #> 8   8  3       1                  1 #> 9   9  2       1                  1 #> 10 10  1       1                  1 #> 11  1 10       2                  1 #> 12  2  9       2                  1 #> 13  3  8       2                  1 #> 14  4  7       2                  1 #> 15  5  6       2                  1 #> 16  6  5       2                  1 #> 17  7  4       2                  1 #> 18  8  3       2                  1 #> 19  9  2       2                  1 #> 20 10  1       2                  1 coords(ply) #>   x y line_id polygon_id #> 1 0 0       1          1 #> 2 1 0       1          1 #> 3 1 1       1          1 #> 4 0 1       1          1 #> 5 0 0       1          1 coords(union_geoms(rep(ply, 2))) #>   x y line_id polygon_id multipolygon_id #> 1 1 0       1          1               1 #> 2 1 1       1          1               1 #> 3 0 1       1          1               1 #> 4 0 0       1          1               1 #> 5 1 0       1          1               1"},{"path":"/reference/distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Distances — distance_euclidean_pairwise","title":"Calculate Distances — distance_euclidean_pairwise","text":"Calculates distances two vectors geometries. number different distance methods can utilized.","code":""},{"path":"/reference/distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Distances — distance_euclidean_pairwise","text":"","code":"distance_euclidean_pairwise(x, y)  distance_hausdorff_pairwise(x, y)  distance_vicenty_pairwise(x, y)  distance_geodesic_pairwise(x, y)  distance_haversine_pairwise(x, y)  distance_euclidean_matrix(x, y)  distance_hausdorff_matrix(x, y)  distance_vicenty_matrix(x, y)  distance_geodesic_matrix(x, y)  distance_haversine_matrix(x, y)"},{"path":"/reference/distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Distances — distance_euclidean_pairwise","text":"x object class rsgeo y object class rsgeo","code":""},{"path":"/reference/distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Distances — distance_euclidean_pairwise","text":"_matrix functions, returns dense matrix distances whereas _pairwise functions return numeric vector.","code":""},{"path":"/reference/distance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Distances — distance_euclidean_pairwise","text":"_pairwise() _matrix() suffixed functions generate distances pairwise dense matrix respectively. pairwise functions calculate distances ith element vector. Whereas matrix functions calculate distance every geometry. Euclidean distance used planar geometries. Haversine, Geodesic, Vicenty methods calculating distance based spherical geometries. concept spherical geometries rsgeo, choose distance measure appropriately.","code":""},{"path":"/reference/distance.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Calculate Distances — distance_euclidean_pairwise","text":"Hausdorff distance calculated using Euclidean distance. Haversine, Geodesic, Vicenty distances work rs_POINT geometries.","code":""},{"path":"/reference/distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Distances — distance_euclidean_pairwise","text":"","code":"set.seed(1) x <- geom_point(runif(5, -1, 1), runif(5, -1, 1)) y <- rev(x)  distance_euclidean_matrix(x, y) #>          [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 1.678069 1.3936593 0.7769445 0.2324579 0.0000000 #> [2,] 1.798381 1.2441299 0.6953524 0.0000000 0.2324579 #> [3,] 1.409373 0.6736956 0.0000000 0.6953524 0.7769445 #> [4,] 1.812225 0.0000000 0.6736956 1.2441299 1.3936593 #> [5,] 0.000000 1.8122247 1.4093730 1.7983809 1.6780693 #> attr(,\"class\") #> [1] \"matrix\" \"array\"  distance_hausdorff_matrix(x, y) #>          [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 1.678069 1.3936593 0.7769445 0.2324579 0.0000000 #> [2,] 1.798381 1.2441299 0.6953524 0.0000000 0.2324579 #> [3,] 1.409373 0.6736956 0.0000000 0.6953524 0.7769445 #> [4,] 1.812225 0.0000000 0.6736956 1.2441299 1.3936593 #> [5,] 0.000000 1.8122247 1.4093730 1.7983809 1.6780693 #> attr(,\"class\") #> [1] \"matrix\" \"array\"  distance_vicenty_matrix(x, y) #>          [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 185558.6 154980.77  86270.25  25847.36      0.00 #> [2,] 198902.8 138252.31  77059.72      0.00  25847.36 #> [3,] 156131.3  74990.08      0.00  77059.72  86270.25 #> [4,] 201203.9      0.00  74990.08 138252.31 154980.77 #> [5,]      0.0 201203.87 156131.25 198902.84 185558.65 #> attr(,\"class\") #> [1] \"matrix\" \"array\"  distance_geodesic_matrix(x, y) #>          [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 185558.6 154980.77  86270.25  25847.36      0.00 #> [2,] 198902.8 138252.31  77059.72      0.00  25847.36 #> [3,] 156131.3  74990.08      0.00  77059.72  86270.25 #> [4,] 201203.9      0.00  74990.08 138252.31 154980.77 #> [5,]      0.0 201203.87 156131.25 198902.84 185558.65 #> attr(,\"class\") #> [1] \"matrix\" \"array\"  distance_haversine_matrix(x, y) #>          [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 186593.0 154961.98  86389.67  25845.81      0.00 #> [2,] 199970.8 138335.46  77318.22      0.00  25845.81 #> [3,] 156714.0  74910.69      0.00  77318.22  86389.67 #> [4,] 201506.7      0.00  74910.69 138335.46 154961.98 #> [5,]      0.0 201506.69 156714.04 199970.82 186593.01 #> attr(,\"class\") #> [1] \"matrix\" \"array\"   distance_euclidean_pairwise(x, y) #> [1] 1.678069 1.244130 0.000000 1.244130 1.678069 distance_hausdorff_pairwise(x, y) #> [1] 1.678069 1.244130 0.000000 1.244130 1.678069 distance_vicenty_pairwise(x, y) #> [1] 185558.6 138252.3      0.0 138252.3 185558.6 distance_geodesic_pairwise(x, y) #> [1] 185558.6 138252.3      0.0 138252.3 185558.6 distance_haversine_pairwise(x, y) #> [1] 186593.0 138335.5      0.0 138335.5 186593.0"},{"path":"/reference/expand_geoms.html","id":null,"dir":"Reference","previous_headings":"","what":"Expand Geometries — expand_geoms","title":"Expand Geometries — expand_geoms","text":"Expands geometries list vectors components.","code":""},{"path":"/reference/expand_geoms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expand Geometries — expand_geoms","text":"","code":"expand_geoms(x)"},{"path":"/reference/expand_geoms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expand Geometries — expand_geoms","text":"x object class rsgeo","code":""},{"path":"/reference/expand_geoms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expand Geometries — expand_geoms","text":"list rsgeo vectors containing original geometry's components new vector.","code":""},{"path":"/reference/expand_geoms.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expand Geometries — expand_geoms","text":"rs_MULTIPOINT expands vector points rs_LINESTRING expands vector points rs_MULTILINESTRING expands vector linestrings rs_POLYGON expands vector linestrings rs_MULTIPOLYGON expands vector polygons wish single vector returned, pass results flatten_geoms().","code":""},{"path":"/reference/expand_geoms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expand Geometries — expand_geoms","text":"","code":"mpnts <- geom_multipoint(runif(10), runif(10), rep.int(1:5, 2)) expand_geoms(mpnts) #> [[1]] #> <rs_POINT[2]> #> [1] Point(Coord { x: 0.20597457489930093, y: 0.9347052311059088 })) #> [2] Point(Coord { x: 0.49769924208521843, y: 0.3861140925437212 })) #>  #> [[2]] #> <rs_POINT[2]> #> [1] Point(Coord { x: 0.7698414199985564, y: 0.26722066872753203 })) #> [2] Point(Coord { x: 0.7774452213197947, y: 0.3403489966876805 }))  #>  #> [[3]] #> <rs_POINT[2]> #> [1] Point(Coord { x: 0.17655675252899528, y: 0.21214252128265798 })) #> [2] Point(Coord { x: 0.7176185082644224, y: 0.013390333158895373 })) #>  #> [[4]] #> <rs_POINT[2]> #> [1] Point(Coord { x: 0.384103718213737, y: 0.12555509596131742 })) #> [2] Point(Coord { x: 0.3800351794343442, y: 0.86969084572047 }))   #>  #> [[5]] #> <rs_POINT[2]> #> [1] Point(Coord { x: 0.6870228466577828, y: 0.651673766085878 }))  #> [2] Point(Coord { x: 0.9919060948304832, y: 0.3823879570700228 })) #>"},{"path":"/reference/extreme_coords.html","id":null,"dir":"Reference","previous_headings":"","what":"Find extremes — extreme_coords","title":"Find extremes — extreme_coords","text":"Find extremes","code":""},{"path":"/reference/extreme_coords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find extremes — extreme_coords","text":"","code":"extreme_coords(x)"},{"path":"/reference/extreme_coords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find extremes — extreme_coords","text":"x geometry","code":""},{"path":"/reference/flatten_geoms.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatten a list of rsgeo vectors — flatten_geoms","title":"Flatten a list of rsgeo vectors — flatten_geoms","text":"Flatten list rsgeo vectors","code":""},{"path":"/reference/flatten_geoms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatten a list of rsgeo vectors — flatten_geoms","text":"","code":"flatten_geoms(x)"},{"path":"/reference/flatten_geoms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatten a list of rsgeo vectors — flatten_geoms","text":"x list object element object class rsgeo","code":""},{"path":"/reference/flatten_geoms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatten a list of rsgeo vectors — flatten_geoms","text":"Returns object class rsgeo","code":""},{"path":"/reference/flatten_geoms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatten a list of rsgeo vectors — flatten_geoms","text":"","code":"pnts <- replicate(   10,   geom_point(runif(1), runif(1)),   simplify = FALSE )  flatten_geoms(pnts) #> <rs_POINT[10]> #>  [1] Point(Coord { x: 0.48208011547103524, y: 0.5995658254250884 }))   #>  [2] Point(Coord { x: 0.4935413070488721, y: 0.1862176014110446 }))    #>  [3] Point(Coord { x: 0.8273733186069876, y: 0.6684667381923646 }))    #>  [4] Point(Coord { x: 0.7942398607265204, y: 0.10794362588785589 }))   #>  [5] Point(Coord { x: 0.723710946040228, y: 0.4112744296435267 }))     #>  [6] Point(Coord { x: 0.8209462941158563, y: 0.6470601938199252 }))    #>  [7] Point(Coord { x: 0.7829327622894198, y: 0.5530363116413355 }))    #>  [8] Point(Coord { x: 0.5297195801977068, y: 0.7893562316894531 }))    #>  [9] Point(Coord { x: 0.023331202333793044, y: 0.47723006503656507 })) #> [10] Point(Coord { x: 0.7323137386702001, y: 0.6927315564826131 }))"},{"path":"/reference/frechet_distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Frechet Distance — frechet_distance","title":"Calculate Frechet Distance — frechet_distance","text":"Given two LineStrings compare thier similarity calculating Fréchet distance.","code":""},{"path":"/reference/frechet_distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Frechet Distance — frechet_distance","text":"","code":"frechet_distance(x, y)"},{"path":"/reference/frechet_distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Frechet Distance — frechet_distance","text":"x object class rs_LINESTRING y object class rs_LINESTRING","code":""},{"path":"/reference/frechet_distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Frechet Distance — frechet_distance","text":"numeric vector","code":""},{"path":"/reference/frechet_distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Frechet Distance — frechet_distance","text":"","code":"x <- geom_linestring(1:10, runif(10, -1, 1)) y <- geom_linestring(1:10, runif(10, -3, 3)) frechet_distance(x, y) #> [1] 2.522016"},{"path":"/reference/geometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Create geometry — geom_point","title":"Create geometry — geom_point","text":"Create geometry Create list points Given matrix x, y coordinates, create list points","code":""},{"path":"/reference/geometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create geometry — geom_point","text":"","code":"geom_point(x, y)  geom_points(x)  geom_points_xy(x, y)  geom_points_matrix(x)  geom_multipoint(x)  geom_multipoints(x)  geom_polygon(x)  geom_polygons(x)  geom_multipolygon(x)  geom_multipolygons(x)  geom_linestring(x)  geom_linestrings(x)  geom_multilinestring(x)  geom_multilinestrings(x)"},{"path":"/reference/haversine_destination.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify a destination point — haversine_destination","title":"Identify a destination point — haversine_destination","text":"Given vector point geometries, bearings, distances, identify destination location.","code":""},{"path":"/reference/haversine_destination.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify a destination point — haversine_destination","text":"","code":"haversine_destination(x, bearing, distance)"},{"path":"/reference/haversine_destination.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify a destination point — haversine_destination","text":"x object class rs_POINT bearing numeric vector specifying degree direction 0 north distance numeric vector specifying distance travel direction specified bearing meters","code":""},{"path":"/reference/haversine_destination.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify a destination point — haversine_destination","text":"object class rs_POINT","code":""},{"path":"/reference/haversine_destination.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify a destination point — haversine_destination","text":"","code":"# create 10 points at the origin pnts <- geom_point(rep(0, 10), rep(0, 10))  # set seed for reproducibiliy set.seed(1)  # generate random bearings bearings <- runif(10, 0, 360)  # generate random distances distances <- runif(10, 10000, 100000)  # find the destinations dests <- haversine_destination(pnts, bearings, distances)  # plot points if (rlang::is_installed(c(\"sf\", \"wk\"))) {   plot(pnts, pch = 3)   plot(dests, add = TRUE, pch = 17) }"},{"path":"/reference/haversine_intermediate.html","id":null,"dir":"Reference","previous_headings":"","what":"Identifies a point between two points — haversine_intermediate","title":"Identifies a point between two points — haversine_intermediate","text":"Identifies location two points great circle along specified fraction distance.","code":""},{"path":"/reference/haversine_intermediate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identifies a point between two points — haversine_intermediate","text":"","code":"haversine_intermediate(x, y, distance)"},{"path":"/reference/haversine_intermediate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identifies a point between two points — haversine_intermediate","text":"x rs_POINT vector y rs_POINT vector distance numeric vector either length 1 length x y","code":""},{"path":"/reference/haversine_intermediate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identifies a point between two points — haversine_intermediate","text":"object class rs_POINT","code":""},{"path":"/reference/haversine_intermediate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identifies a point between two points — haversine_intermediate","text":"","code":"x <- geom_point(1:10, rep(5, 10)) y <- geom_point(1:10, rep(0, 10)) res <- haversine_intermediate(x, y, 0.5) if (rlang::is_installed(c(\"wk\", \"sf\"))) {   plot(     c(x, y, res),     col = sort(rep.int(c(\"red\", \"blue\", \"purple\"), 10)),     pch = 16   ) }"},{"path":"/reference/length.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate LineString Length — length_euclidean","title":"Calculate LineString Length — length_euclidean","text":"given LineString MultiLineString geometry, calculate length. geometries return value NA.","code":""},{"path":"/reference/length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate LineString Length — length_euclidean","text":"","code":"length_euclidean(x)  length_geodesic(x)  length_vincenty(x)  length_haversine(x)"},{"path":"/reference/length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate LineString Length — length_euclidean","text":"x object class rsgeo","code":""},{"path":"/reference/length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate LineString Length — length_euclidean","text":"numeric vector","code":""},{"path":[]},{"path":"/reference/length.html","id":"notes","dir":"Reference","previous_headings":"","what":"Notes","title":"Calculate LineString Length — length_euclidean","text":"Vicenty, Geodesic, Haversine methods return units meters. Geodesic length always converge accurate Vicenty methods. Haversine uses mean earth radius 6371.088 km. See geo docs details.","code":""},{"path":"/reference/length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate LineString Length — length_euclidean","text":"","code":"set.seed(0) y <- runif(25, -5, 5) x <- 1:25  ln <- geom_linestring(x, y)  length_euclidean(ln) #> [1] 91.41732 length_geodesic(ln) #> [1] 10114260 length_vincenty(ln) #> [1] 10114260 length_haversine(ln) #> [1] 10164090"},{"path":"/reference/line_interpolate_point.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolate a Point on a LineString — line_interpolate_point","title":"Interpolate a Point on a LineString — line_interpolate_point","text":"Finds point lies given fraction along line.","code":""},{"path":"/reference/line_interpolate_point.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolate a Point on a LineString — line_interpolate_point","text":"","code":"line_interpolate_point(x, fraction)"},{"path":"/reference/line_interpolate_point.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolate a Point on a LineString — line_interpolate_point","text":"x object class rs_LINESTRING fraction numeric vector length 1 length x. Must value 0 1 inclusive.","code":""},{"path":"/reference/line_interpolate_point.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolate a Point on a LineString — line_interpolate_point","text":"object class rs_POINT","code":""},{"path":"/reference/line_interpolate_point.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpolate a Point on a LineString — line_interpolate_point","text":"","code":"x <- geom_linestring(c(-1, 0, 0), c(0, 0, 1)) line_interpolate_point(x, 0.5) #> <rs_POINT[1]> #> [1] Point(Coord { x: 0.0, y: 0.0 }))"},{"path":"/reference/line_segmentize.html","id":null,"dir":"Reference","previous_headings":"","what":"Segments a LineString into n equal length LineStrings — line_segmentize","title":"Segments a LineString into n equal length LineStrings — line_segmentize","text":"Given LineString, segment n equal length LineStrings. n LineStrings provided MultiLineString can expanded using expand_geoms() consequently flattened using flatten_geoms() desired.","code":""},{"path":"/reference/line_segmentize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Segments a LineString into n equal length LineStrings — line_segmentize","text":"","code":"line_segmentize(x, n)"},{"path":"/reference/line_segmentize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Segments a LineString into n equal length LineStrings — line_segmentize","text":"x object class rs_LINESTRING n integer vector determining number equal length LineStrings create","code":""},{"path":"/reference/line_segmentize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Segments a LineString into n equal length LineStrings — line_segmentize","text":"vector class rs_MULTILINESTRING","code":""},{"path":"/reference/line_segmentize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Segments a LineString into n equal length LineStrings — line_segmentize","text":"","code":"x <- geom_linestring(1:10, runif(10, -1, 1))  segs <- line_segmentize(x, 3)  flatten_geoms(   expand_geoms(segs) ) #> <rs_LINESTRING[3]> #> [1] LineString([Coord { x: 1.0, y: -0.46555866254493594 }, Coord { x: 2.0, y: ... #> [2] LineString([Coord { x: 4.018943076103605, y: -0.21676205444953042 }, Coord... #> [3] LineString([Coord { x: 6.690996001567895, y: -0.12343073387055387 }, Coord..."},{"path":"/reference/locate_point_on_line.html","id":null,"dir":"Reference","previous_headings":"","what":"Locate a Point on a LineString — locate_point_on_line","title":"Locate a Point on a LineString — locate_point_on_line","text":"Calculates fraction LineString's length point closes corresponding point y.","code":""},{"path":"/reference/locate_point_on_line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Locate a Point on a LineString — locate_point_on_line","text":"","code":"locate_point_on_line(x, y)"},{"path":"/reference/locate_point_on_line.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Locate a Point on a LineString — locate_point_on_line","text":"x object class rs_LINESTRING y object class rs_POINT","code":""},{"path":"/reference/locate_point_on_line.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Locate a Point on a LineString — locate_point_on_line","text":"numeric vector containing fraction LineString need traveled reach closest point.","code":""},{"path":"/reference/locate_point_on_line.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Locate a Point on a LineString — locate_point_on_line","text":"","code":"x <- geom_linestring(c(-1, 0, 0), c(0, 0, 1)) y <- geom_point(-0.5, 0) locate_point_on_line(x, y) #> [1] 0.25"},{"path":"/reference/plot.rsgeo.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Geometries — plot.rsgeo","title":"Plot Geometries — plot.rsgeo","text":"Plot Geometries","code":""},{"path":"/reference/plot.rsgeo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Geometries — plot.rsgeo","text":"","code":"# S3 method for rsgeo plot(x, ...)"},{"path":"/reference/plot.rsgeo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Geometries — plot.rsgeo","text":"x object class rsgeo ... arguments passed wk::wk_plot()","code":""},{"path":"/reference/plot.rsgeo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Geometries — plot.rsgeo","text":"Nothing.","code":""},{"path":"/reference/plot.rsgeo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Geometries — plot.rsgeo","text":"Plotting geometries utilizes wk::wk_plot(). rust geometries handled first converting sfc object wk::wk_handle() method thus requiring packages plotting.","code":""},{"path":"/reference/plot.rsgeo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot Geometries — plot.rsgeo","text":"","code":"if (rlang::is_installed(c(\"sf\", \"wk\"))) {   plot(geom_linestring(1:10, runif(10))) }"},{"path":"/reference/predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial Predicates — contains","title":"Spatial Predicates — contains","text":"Spatial Predicates","code":""},{"path":"/reference/predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial Predicates — contains","text":"","code":"contains(x, y)  contains_sparse(x, y)  contains_pairwise(x, y)  intersects(x, y)  intersects_sparse(x, y)  intersects_pairwise(x, y)  within(x, y)  within_sparse(x, y)  within_pairwise(x, y)"},{"path":"/reference/print.html","id":null,"dir":"Reference","previous_headings":"","what":"Printing and formatting — print.point","title":"Printing and formatting — print.point","text":"Printing formatting","code":""},{"path":"/reference/print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Printing and formatting — print.point","text":"","code":"# S3 method for point print(x, width = NULL)  # S3 method for multipoint print(x, width = NULL)  # S3 method for polygon print(x, width = NULL)  # S3 method for multipolygon print(x, width = NULL)  # S3 method for linestring print(x, width = NULL)  # S3 method for multilinestring print(x, width = NULL)"},{"path":"/reference/read_geojson.html","id":null,"dir":"Reference","previous_headings":"","what":"Read GeoJSON file — read_geojson","title":"Read GeoJSON file — read_geojson","text":"Read GeoJson file using geojson crate. function crash geojson files ~ 50mb +. Working though....","code":""},{"path":"/reference/read_geojson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read GeoJSON file — read_geojson","text":"","code":"read_geojson(filepath)"},{"path":"/reference/read_geojson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read GeoJSON file — read_geojson","text":"filepath file path read","code":""},{"path":"/reference/read_geojson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read GeoJSON file — read_geojson","text":"improve reading speed set --max-ppsize=500000 creating R session.","code":""},{"path":"/reference/rstar_rtree.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an rstar RTree from a vector of geometry — rstar_rtree","title":"Create an rstar RTree from a vector of geometry — rstar_rtree","text":"Create rstar RTree vector geometry","code":""},{"path":"/reference/rstar_rtree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an rstar RTree from a vector of geometry — rstar_rtree","text":"","code":"rstar_rtree(x)"},{"path":"/reference/rstar_rtree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an rstar RTree from a vector of geometry — rstar_rtree","text":"x vector rust geometry","code":""},{"path":"/reference/simplify.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify Geometry — simplify_geoms","title":"Simplify Geometry — simplify_geoms","text":"Simplifies LineStrings, Polygons, Multi- counterparts.","code":""},{"path":"/reference/simplify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify Geometry — simplify_geoms","text":"","code":"simplify_geoms(x, epsilon)  simplify_vw_geoms(x, epsilon)  simplify_vw_preserve_geoms(x, epsilon)"},{"path":"/reference/simplify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify Geometry — simplify_geoms","text":"x object class rsgeo epsilon tolerance parameter. equal less 0.","code":""},{"path":"/reference/simplify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify Geometry — simplify_geoms","text":"object class rsgeo","code":""},{"path":"/reference/simplify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simplify Geometry — simplify_geoms","text":"Simplify functions use Ramer–Douglas–Peucker algorithm. Functions vw use Visvalingam-Whyatt algorithm. see geo docs.","code":""},{"path":"/reference/simplify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify Geometry — simplify_geoms","text":"","code":"x <- geom_linestring(1:100, runif(100, 5, 10))  simplify_geoms(x, 3) #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 1.0, y: 7.648597900988534 }, Coord { x: 8.0, y: 9.3... simplify_vw_geoms(x, 2) #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 1.0, y: 7.648597900988534 }, Coord { x: 2.0, y: 8.9... simplify_vw_preserve_geoms(x, 100) #> <rs_LINESTRING[1]> #> [1] LineString([Coord { x: 1.0, y: 7.648597900988534 }, Coord { x: 36.0, y: 9...."},{"path":"/reference/simplify_geom.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplfiy Geometries — simplify_geom","title":"Simplfiy Geometries — simplify_geom","text":"Simplfiy Geometries","code":""},{"path":"/reference/simplify_geom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplfiy Geometries — simplify_geom","text":"","code":"simplify_geom(x, epsilon)  simplify_geoms(x, epsilon)  simplify_vw_geom(x, epsilon)  simplify_vw_geoms(x, epsilon)"},{"path":"/reference/topology.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary Predicates — intersects_sparse","title":"Binary Predicates — intersects_sparse","text":"Functions ascertain binary relationship two geometry vectors. Binary predicates provided pairwise sparse matrix.","code":""},{"path":"/reference/topology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary Predicates — intersects_sparse","text":"","code":"intersects_sparse(x, y)  intersects_pairwise(x, y)  contains_sparse(x, y)  contains_pairwise(x, y)  within_sparse(x, y)  within_pairwise(x, y)"},{"path":"/reference/topology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary Predicates — intersects_sparse","text":"x object class rsgeo y object class rsgeo","code":""},{"path":"/reference/topology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary Predicates — intersects_sparse","text":"_sparse list integer vectors containing position geometry y _pairwise logical vector","code":""},{"path":"/reference/topology.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binary Predicates — intersects_sparse","text":"","code":"if (rlang::is_installed(\"sf\")) {     nc <- sf::st_read(       system.file(\"shape/nc.shp\", package = \"sf\"),       quiet = TRUE     )          x <- as_rsgeo(nc$geometry[1:5])     y <- rev(x)          # intersects     intersects_sparse(x, y)     intersects_pairwise(x, y)     # contains      contains_sparse(x, y)     contains_pairwise(x, y)     # within     within_sparse(x, y)     within_pairwise(x, y) } #> [1] FALSE FALSE  TRUE FALSE FALSE"},{"path":"/reference/vector-compatibility.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal vet — vector-compatibility","title":"Internal vet — vector-compatibility","text":"Internal vet","code":""},{"path":"/reference/wkb.html","id":null,"dir":"Reference","previous_headings":"","what":"WKB Translation — wkb_from_geom","title":"WKB Translation — wkb_from_geom","text":"WKB Translation","code":""},{"path":"/reference/wkb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"WKB Translation — wkb_from_geom","text":"","code":"wkb_from_geom(x)  wkb_from_geoms(x)  wkb_to_geom(x)  wkb_to_geoms(x)"},{"path":"/reference/wkt.html","id":null,"dir":"Reference","previous_headings":"","what":"WKT translation — wkt_to_geom","title":"WKT translation — wkt_to_geom","text":"WKT translation","code":""},{"path":"/reference/wkt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"WKT translation — wkt_to_geom","text":"","code":"wkt_to_geom(x)  wkt_from_geom(x)  wkt_to_geoms(x)  wkt_from_geoms(x)"},{"path":"/news/index.html","id":"rsgeo-015","dir":"Changelog","previous_headings":"","what":"rsgeo 0.1.5","title":"rsgeo 0.1.5","text":"CRAN release: 2023-09-02 Initial CRAN release. couldn’t possible without attention detail @eitsupi, guidance help @cgmossa, @Ilia-Kosenkov, @sorhwell prior art @yutannihilation @jeroen","code":""},{"path":"/news/index.html","id":"rsgeo-014","dir":"Changelog","previous_headings":"","what":"rsgeo 0.1.4","title":"rsgeo 0.1.4","text":"vendoring rust dependencies make rsgeo capable published CRAN","code":""},{"path":"/news/index.html","id":"rsgeo-013","dir":"Changelog","previous_headings":"","what":"rsgeo 0.1.3","title":"rsgeo 0.1.3","text":"adding additional parallelization geodesic, Haversine, Vincenty lengths parallelization added minimum bounding rect line_segmentize() now parallelized","code":""},{"path":"/news/index.html","id":"rsgeo-010","dir":"Changelog","previous_headings":"","what":"rsgeo 0.1.0","title":"rsgeo 0.1.0","text":"Complete rewrite rsgeo ground . distances matrices calculated parallel using rayon removes cloning possible reducing overall memory footprint even ","code":""},{"path":"/news/index.html","id":"rsgeo-0009000","dir":"Changelog","previous_headings":"","what":"rsgeo 0.0.0.9000","title":"rsgeo 0.0.0.9000","text":"Added NEWS.md file track changes package.","code":""}]
